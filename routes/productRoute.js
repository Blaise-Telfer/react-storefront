const express = require("express");
const router = express.Router();
const Product = require("../models/productModel");
const Category = require("../models/categoryModel");
const { isAuth, isAdmin } = require('../middleware/authParameters');
const keys = require("../config/config");


//cloudinary configuration 
const cloudinary = require("cloudinary");
cloudinary.config({
  cloud_name: keys.CLOUD_NAME,
  api_key: keys.CLOUD_API,
  api_secret: keys.CLOUD_SECRET
});
//multer configuration
const multer = require("multer");
const storage = multer.diskStorage({
  filename: function(req, file, callback) {
    callback(null, Date.now() + file.originalname);
  }
});
// accept image files only
const imageFilter = function(req, file, cb) {
  if (!file.originalname.match(/\.(jpg|jpeg|JPG|JPEG|png)$/i)) {
    return cb(new Error("Only image files are accepted!"), false);
  }
  cb(null, true);
};
const upload = multer({ storage: storage, fileFilter: imageFilter });



//create product
router.post('/', isAuth, isAdmin, upload.single("image"), async (req, res) => {
  try{
	const {name, price, brand, countInStock, description, categoryId} = req.body;
	if( name=="undefined" || description=="undefined" || price=="undefined" || brand=="undefined" || countInStock=="undefined" || !categoryId || categoryId==0 ){
	  res.status(400).json({message: "All fields required."})
	}
	if(!req.file){
	  res.status(400).json({message: "Image required."})
	}
	const categoryFound = await Category.findById({ _id: categoryId });
    if (!categoryFound) {
 	  return res.status(400).json({ message: "Category not found" });
    }
	const usedName = await Product.findOne({name: name});
	if(usedName){
	  return res.status(400).json({ message: "Product already exists" });
	}
	
	//path for Cloudinary image upload
	cloudinary.v2.uploader.upload(req.file.path, async function(error, result){
	  if (error) {
	    return res.status(400).json({success: false, message: error});
	  }
	  const newPic = result.secure_url;
	  const product = new Product({
        name,
        price,
        description,
		brand,
		countInStock,
		category: categoryFound.name, 
	    image: newPic
	  });
	  
	  const newProduct = await product.save();
	  if (newProduct) {
		return res.status(200).json({ message: "New Product Created", data: newProduct });
	  }
	});
  }
  catch (error){
	res.status(400).json({message: "Error creating the product."})
  }
});


//update product
router.put("/:id", isAuth, isAdmin, upload.single("image"), async (req, res) => {
  try{
	const productId = req.params.id;
	const { name, description, price, categoryId, brand, countInStock } = req.body;
	if( !name || !description || !price || !brand || !countInStock ){
	  res.status(400).json({message: "All fields required."})
	}
	const product = await Product.findById(productId);
	
	if (product) {
		//if there is no image
		if(!req.file){
		  //if category was updated
		  if(categoryId){
			let categoryFound = await Category.findById({ _id: categoryId });
			product.name = name;
			product.description = description;
			product.price = price;
			product.brand = brand;
			product.countInStock = countInStock;
			product.category = categoryFound.name
		  } else{
			product.name = name;
			product.description = description;
			product.price = price;
			product.brand = brand;
			product.countInStock = countInStock;
		  }
		  const updatedProduct = await product.save();
		  if (updatedProduct) {
			return res.status(200).json({ message: "Product Updated", data: updatedProduct });
		  }
		}
		else if(req.file){
		  //path for Cloudinary image upload
		  cloudinary.v2.uploader.upload(req.file.path, async function(error, result){
			if (error) {
			  return res.status(400).json({success: false, message: error});
			}
			//new url generated by Cloudinary
			const newPic = result.secure_url;
			if(categoryId){
			  let categoryFound = await Category.findById({ _id: categoryId });
			  product.name = name;
			  product.description = description;
			  product.price = price;
			  product.brand = brand;
			  product.countInStock = countInStock;
			  product.category = categoryFound.name;
			  product.image = newPic;
		    } else{
			  product.name = name;
			  product.description = description;
			  product.price = price;
			  product.brand = brand;
			  product.countInStock = countInStock;
			  product.image = newPic;
		    }
			const updatedProduct = await product.save();
			if (updatedProduct) {
			  return res.status(200).json({ message: "New Product Created", data: updatedProduct });
			}
		  });
		}
	} else{
	  res.status(400).json({message: "Error in updating product."})
	}
  }
  catch (error){
	res.status(400).json({message: "Error in updating product."})
  }
});


//fetch product details
router.get("/:id", async (req, res) => {
  try{
	const productId = req.params.id;
	const product = await Product.findById(productId);
	if (product) {
	  res.json(product);
	}
  }
  catch (error){
	res.status(400).json({message: "That product number doesn't match our records."})
  }
});


//fetch searchbar list
router.get("/", async (req, res) => {
  const category = req.query.category ? { category: req.query.category } : {};
  const searchKeyword = req.query.searchKeyword
    ? {
        name: {
          $regex: req.query.searchKeyword,
          $options: 'i',
        },
      }
    : {};
  
  const products = await Product.find({ ...category, ...searchKeyword });
  if (products){
	return res.status(200).json(products);
  }
  else{
	return res.status(400).json({ message: "No Products Available" });
  }
});

//fetch filtered products
router.post("/search", async (req, res) => {
    let limit = req.body.limit ? parseInt(req.body.limit) : 100;
    let skip = parseInt(req.body.skip);
    let findArgs = {};

	for (let key in req.body.filters) {
		if (req.body.filters[key].length > 0) {
			if (key === 'price') {
                findArgs[key] = {
                    $gte: req.body.filters[key][0],
                    $lte: req.body.filters[key][1]
                };
            } else {
                findArgs[key] = req.body.filters[key];
            }
        }
    }
    Product.find(findArgs)
        .skip(skip)
        .limit(limit)
        .exec((err, data) => {
			if (err) {
                return res.status(400).json({
                    error: 'Products not found'
                });
            }
            res.json({
                size: data.length,
                data
            });
        });
});


//post a review
router.post('/:id/review', isAuth, async (req, res) => {
  const product = await Product.findById(req.params.id);
  if (product) {
	const alreadyReviewed = product.reviews.find(
      (r) => r.user == req.user.id 
    );
	
	if (alreadyReviewed) {
      return res.status(400).json({ message: "Product already reviewed" });
    }
	
	const review = {
      name: req.user.username,
	  user: req.user.id,
      rating: Number(req.body.rating),
      text: req.body.text,
    };
	
    product.reviews.push(review);
    product.numReviews = product.reviews.length;
    product.rating =
      product.reviews.reduce((a, c) => c.rating + a, 0) /
      product.reviews.length;
    const updatedProduct = await product.save();
    res.status(201).send({
      data: updatedProduct.reviews[updatedProduct.reviews.length - 1],
      message: "Review saved successfully."
    });
	
  } else {
    res.status(404).send({ message: "Product Not Found" });
  }
});


//delete a product
router.delete('/:id', isAuth, isAdmin, async (req, res) => {
  try{
	const deletedProduct = await Product.findById(req.params.id);
    if (deletedProduct) {
      await deletedProduct.remove();
      return res.status(200).json({ message: "Product Deleted" });
    }
  }
  catch (error){
	return res.status(400).json({ message: "Error in deleting product" });
  }
});


module.exports = router;